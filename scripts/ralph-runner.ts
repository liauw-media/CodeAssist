#!/usr/bin/env npx ts-node
/**
 * Ralph Wiggum - Autonomous Development Runner
 * Powered by Claude Agent SDK
 *
 * Usage:
 *   npx ts-node ralph-runner.ts --issue=123
 *   npx ts-node ralph-runner.ts --epic=200
 *   npx ts-node ralph-runner.ts --issue=123 --preset=production
 *   npx ts-node ralph-runner.ts --issue=123 --supervised
 */

import {
  query,
  ClaudeAgentOptions,
  AgentDefinition,
  HookCallback,
} from "@anthropic-ai/claude-agent-sdk";
import { appendFileSync, readFileSync, existsSync, writeFileSync } from "fs";
import { join } from "path";
import * as yaml from "yaml";

// ============================================
// TYPES
// ============================================
interface GateConfig {
  weight: number;
  required: boolean;
  auto_fix: boolean;
  command?: string;
  description?: string;
  thresholds?: Record<string, number>;
  parallel_group?: number;
}

interface AutonomousConfig {
  target_score: number;
  max_iterations: number;
  iteration_delay: number;
  gates: Record<string, GateConfig>;
  presets?: Record<string, Partial<AutonomousConfig>>;
  safety: {
    max_api_calls_per_hour: number;
    max_issues_created_per_run: number;
    forbidden: string[];
  };
  git_rules: {
    protected_branches: string[];
    commit_rules: {
      forbidden_patterns: string[];
      auto_strip: boolean;
    };
  };
}

interface GateResult {
  gate: string;
  score: number;
  maxScore: number;
  passed: boolean;
  issues: GateIssue[];
  duration: number;
  autoFixed: number;
}

interface GateIssue {
  severity: "critical" | "high" | "medium" | "low" | "info";
  title: string;
  file?: string;
  line?: number;
  description: string;
  recommendation?: string;
  autoFixable: boolean;
}

interface IterationResult {
  iteration: number;
  totalScore: number;
  targetScore: number;
  gates: GateResult[];
  passed: boolean;
  duration: number;
  apiCalls: number;
}

interface RunMetrics {
  startTime: Date;
  iterations: number;
  totalApiCalls: number;
  issuesCreated: number;
  autoFixesApplied: number;
  linesChanged: number;
  filesModified: string[];
}

// ============================================
// CONFIGURATION
// ============================================
const CONFIG_PATH = ".claude/autonomous.yml";
const AUDIT_LOG = "./autonomous-audit.log";
const METRICS_FILE = "./autonomous-metrics.json";
const CACHE_DIR = ".claude/cache";

function loadConfig(preset?: string): AutonomousConfig {
  const defaultConfig: AutonomousConfig = {
    target_score: 95,
    max_iterations: 15,
    iteration_delay: 5,
    gates: {
      test: { weight: 25, required: true, auto_fix: true, parallel_group: 1 },
      security: { weight: 25, required: true, auto_fix: true, parallel_group: 1 },
      build: { weight: 15, required: true, auto_fix: true, parallel_group: 1 },
      review: { weight: 20, required: false, auto_fix: true, parallel_group: 2 },
      mentor: { weight: 10, required: false, auto_fix: false, parallel_group: 2 },
      ux: { weight: 5, required: false, auto_fix: false, parallel_group: 2 },
      architect: { weight: 0, required: false, auto_fix: false, parallel_group: 3 },
      devops: { weight: 0, required: false, auto_fix: false, parallel_group: 3 },
    },
    safety: {
      max_api_calls_per_hour: 100,
      max_issues_created_per_run: 10,
      forbidden: ["force_push", "push_to_main", "auto_merge"],
    },
    git_rules: {
      protected_branches: ["main", "master", "staging"],
      commit_rules: {
        forbidden_patterns: [
          "Co-Authored-By: Claude",
          "Co-Authored-By:.*anthropic",
          "Generated by Claude",
          "AI-generated",
        ],
        auto_strip: true,
      },
    },
  };

  if (existsSync(CONFIG_PATH)) {
    try {
      const fileConfig = yaml.parse(readFileSync(CONFIG_PATH, "utf-8"));
      Object.assign(defaultConfig, fileConfig);
    } catch (e) {
      console.warn("Failed to parse autonomous.yml, using defaults");
    }
  }

  // Apply preset if specified
  if (preset && defaultConfig.presets?.[preset]) {
    Object.assign(defaultConfig, defaultConfig.presets[preset]);
  }

  return defaultConfig;
}

// ============================================
// QUALITY GATE SUBAGENTS
// ============================================
const qualityGateAgents: Record<string, AgentDefinition> = {
  // === TIER 1: Required Gates ===

  "test-runner": {
    description: "Run tests and report coverage",
    prompt: `
You are a test execution specialist. Run the project's test suite.

STEPS:
1. Detect test framework (jest, pytest, phpunit, cargo test, go test)
2. Run tests with coverage
3. Parse results

OUTPUT JSON:
{
  "passed": boolean,
  "total": number,
  "failed": number,
  "skipped": number,
  "coverage": number,
  "failures": [{ "test": string, "error": string, "file": string }],
  "score": number
}

SCORING:
- All tests pass: +20 points
- Coverage >= 80%: +5 points
- Coverage >= 90%: +2 bonus
- Each failure: -5 points (min 0)
`,
    tools: ["Bash", "Read", "Glob"],
  },

  "security-auditor": {
    description: "Security vulnerability scanner",
    prompt: `
You are a security auditor. Scan for vulnerabilities.

CHECK FOR:
1. Hardcoded secrets (API keys, passwords, tokens)
2. SQL injection risks (string concatenation in queries)
3. XSS vulnerabilities (unescaped output)
4. Command injection (user input in shell commands)
5. Insecure dependencies (npm audit, composer audit)
6. Weak cryptography (MD5, SHA1 for passwords)
7. Missing input validation
8. Exposed sensitive endpoints

OUTPUT JSON:
{
  "critical": number,
  "high": number,
  "medium": number,
  "low": number,
  "issues": [{
    "severity": "critical|high|medium|low",
    "title": string,
    "file": string,
    "line": number,
    "description": string,
    "recommendation": string,
    "autoFixable": boolean
  }],
  "score": number
}

SCORING:
- Base: 25 points
- Critical: -25 (blocker)
- High: -10 (blocker)
- Medium: -1 each (max -5)
- Low: no deduction (create issues)
`,
    tools: ["Read", "Grep", "Glob", "Bash"],
  },

  "build-fixer": {
    description: "Build and fix compilation errors",
    prompt: `
You are a build specialist. Build the project and fix errors.

STEPS:
1. Detect build system (npm, composer, cargo, go, make)
2. Run build command
3. If fails, analyze errors and fix
4. Retry up to 5 times

OUTPUT JSON:
{
  "success": boolean,
  "errors": [{ "message": string, "file": string, "line": number }],
  "fixed": [{ "error": string, "fix": string }],
  "attempts": number,
  "score": number
}

SCORING:
- Build succeeds: 15 points
- Build fails: 0 points (blocker)
`,
    tools: ["Bash", "Read", "Edit", "Glob"],
  },

  // === TIER 2: Quality Gates ===

  "code-reviewer": {
    description: "Code quality and style review",
    prompt: `
You are a code review specialist. Review for quality issues.

CHECK FOR:
1. Code smells (long functions, deep nesting, magic numbers)
2. Duplication (copy-paste code)
3. Complexity (cyclomatic complexity > 10)
4. Naming (unclear variable/function names)
5. Dead code (unused variables, unreachable code)
6. Missing error handling

AUTO-FIX:
- Unused imports
- Formatting issues
- Simple refactors

OUTPUT JSON:
{
  "smells": number,
  "duplication_percent": number,
  "complexity_issues": [{ "function": string, "file": string, "complexity": number }],
  "fixable": [{ "issue": string, "file": string, "fix": string }],
  "unfixable": [{ "issue": string, "file": string, "recommendation": string }],
  "fixed_count": number,
  "score": number
}

SCORING:
- Base: 20 points
- Each smell: -2 (max -10)
- Duplication > 5%: -5
- Complexity issues: -1 each
`,
    tools: ["Read", "Edit", "Glob", "Grep", "Bash"],
  },

  "mentor-advisor": {
    description: "Architecture and design review",
    prompt: `
You are a senior architect mentor. Review architecture decisions.

EVALUATE:
1. SOLID principles adherence
2. Design patterns usage
3. Separation of concerns
4. Dependency management
5. Scalability considerations
6. Technical debt
7. Performance anti-patterns

DO NOT auto-fix. Only advise.

OUTPUT JSON:
{
  "concerns": [{
    "category": "architecture|patterns|scalability|performance|debt",
    "severity": "high|medium|low",
    "title": string,
    "description": string,
    "recommendation": string,
    "effort": "low|medium|high"
  }],
  "strengths": [string],
  "recommendations": [string],
  "score": number
}

SCORING:
- Base: 10 points
- High concern: -3
- Medium concern: -1
- Many strengths: +1 bonus
`,
    tools: ["Read", "Glob", "Grep"],
  },

  "ux-reviewer": {
    description: "UX and accessibility review",
    prompt: `
You are a UX specialist. Review user experience and accessibility.

CHECK FOR:
1. Accessibility (WCAG 2.1 AA compliance)
   - Alt text on images
   - ARIA labels
   - Keyboard navigation
   - Color contrast
2. Responsive design
3. Loading states
4. Error messages (user-friendly)
5. Form validation UX
6. Consistent styling

APPLIES TO: Files with frontend code (tsx, jsx, vue, html, css)

OUTPUT JSON:
{
  "a11y_issues": [{ "rule": string, "element": string, "file": string, "fix": string }],
  "ux_issues": [{ "type": string, "description": string, "file": string }],
  "responsive_ok": boolean,
  "score": number
}

SCORING:
- Base: 5 points
- A11y violation: -1 each
- Major UX issue: -1
`,
    tools: ["Read", "Glob", "Grep"],
  },

  // === TIER 3: Advisory Gates (0 weight, creates issues) ===

  "architect-advisor": {
    description: "System architecture and security hardening advisor",
    prompt: `
You are a system architect specializing in security and performance.

ANALYZE:
1. Authentication/authorization design
2. API security (rate limiting, input validation)
3. Data flow and privacy
4. Infrastructure security posture
5. Caching strategy
6. Database query optimization
7. Horizontal scaling readiness
8. Disaster recovery considerations

OUTPUT JSON:
{
  "security_posture": "strong|adequate|weak",
  "performance_rating": "optimized|acceptable|needs_work",
  "findings": [{
    "category": "security|performance|scalability|reliability",
    "severity": "critical|high|medium|low",
    "title": string,
    "current_state": string,
    "recommendation": string,
    "implementation_effort": "hours|days|weeks"
  }],
  "quick_wins": [string],
  "roadmap": [{ "phase": string, "items": [string] }]
}

This gate does not affect score but creates issues for findings.
`,
    tools: ["Read", "Glob", "Grep"],
  },

  "devops-advisor": {
    description: "CI/CD and infrastructure review",
    prompt: `
You are a DevOps engineer. Review deployment and infrastructure.

ANALYZE:
1. CI/CD pipeline configuration
2. Docker/container setup
3. Environment configuration
4. Secrets management
5. Monitoring and logging
6. Deployment strategy
7. Infrastructure as Code
8. Backup and recovery

CHECK FILES:
- .github/workflows/*.yml
- Dockerfile, docker-compose.yml
- terraform/, ansible/
- k8s/, helm/
- .env.example

OUTPUT JSON:
{
  "ci_cd_health": "healthy|needs_attention|broken",
  "container_health": "optimized|acceptable|needs_work|missing",
  "findings": [{
    "category": "ci_cd|containers|secrets|monitoring|deployment",
    "severity": "critical|high|medium|low",
    "title": string,
    "description": string,
    "recommendation": string
  }],
  "missing_essentials": [string],
  "recommendations": [string]
}

This gate does not affect score but creates issues for findings.
`,
    tools: ["Read", "Glob", "Grep"],
  },
};

// ============================================
// HOOKS: Safety + Audit + Git Rules
// ============================================
let apiCallCount = 0;
const metrics: RunMetrics = {
  startTime: new Date(),
  iterations: 0,
  totalApiCalls: 0,
  issuesCreated: 0,
  autoFixesApplied: 0,
  linesChanged: 0,
  filesModified: [],
};

const auditLog: HookCallback = async (input, toolUseId, context) => {
  const timestamp = new Date().toISOString();
  const toolInput = (input as any).tool_input || {};

  const logEntry = {
    timestamp,
    tool: (input as any).tool,
    file: toolInput.file_path || toolInput.path,
    command: toolInput.command?.substring(0, 100),
  };

  appendFileSync(AUDIT_LOG, JSON.stringify(logEntry) + "\n");

  // Track file modifications
  if (toolInput.file_path && !metrics.filesModified.includes(toolInput.file_path)) {
    metrics.filesModified.push(toolInput.file_path);
  }

  return {};
};

const blockForbiddenGit: HookCallback = async (input) => {
  const command = (input as any).tool_input?.command || "";
  const config = loadConfig();

  // Block direct push to protected branches
  for (const branch of config.git_rules.protected_branches) {
    if (new RegExp(`git push.*${branch}`).test(command)) {
      return {
        decision: "block",
        message: `[BLOCKED] Direct push to ${branch}. Use PR workflow.`,
      };
    }
  }

  // Block force push
  if (/git push.*--force/.test(command)) {
    return {
      decision: "block",
      message: "[BLOCKED] Force push is forbidden.",
    };
  }

  // Block destructive operations
  if (/git reset --hard/.test(command)) {
    return {
      decision: "block",
      message: "[BLOCKED] Hard reset requires manual confirmation.",
    };
  }

  return {};
};

const stripClaudeAttribution: HookCallback = async (input) => {
  const command = (input as any).tool_input?.command || "";
  const config = loadConfig();

  if (!command.includes("git commit")) {
    return {};
  }

  let sanitizedCommand = command;
  for (const pattern of config.git_rules.commit_rules.forbidden_patterns) {
    sanitizedCommand = sanitizedCommand.replace(new RegExp(pattern, "gi"), "");
  }

  if (sanitizedCommand !== command) {
    console.log("   [HOOK] Stripped AI attribution from commit");
    return {
      decision: "modify",
      tool_input: { command: sanitizedCommand },
    };
  }

  return {};
};

const rateLimiter: HookCallback = async () => {
  apiCallCount++;
  metrics.totalApiCalls++;

  const config = loadConfig();
  if (apiCallCount > config.safety.max_api_calls_per_hour) {
    return {
      decision: "block",
      message: "[RATE LIMIT] API call limit exceeded. Pausing for cooldown.",
    };
  }

  return {};
};

// ============================================
// PARALLEL GATE EXECUTION
// ============================================
async function runGatesInParallel(
  gates: string[],
  sessionId: string,
  config: AutonomousConfig
): Promise<GateResult[]> {
  const results: GateResult[] = [];

  // Group gates by parallel_group
  const groups = new Map<number, string[]>();
  for (const gate of gates) {
    const group = config.gates[gate]?.parallel_group || 0;
    if (!groups.has(group)) {
      groups.set(group, []);
    }
    groups.get(group)!.push(gate);
  }

  // Execute groups sequentially, gates within group in parallel
  const sortedGroups = Array.from(groups.keys()).sort();

  for (const groupNum of sortedGroups) {
    const groupGates = groups.get(groupNum)!;
    console.log(`\n   [Group ${groupNum}] Running: ${groupGates.join(", ")}`);

    const groupPromises = groupGates.map((gate) =>
      runSingleGate(gate, sessionId, config)
    );

    const groupResults = await Promise.all(groupPromises);
    results.push(...groupResults);

    // Check for blockers before continuing to next group
    const blockers = groupResults.filter(
      (r) => config.gates[r.gate]?.required && !r.passed
    );

    if (blockers.length > 0) {
      console.log(`   [BLOCKED] Required gate(s) failed: ${blockers.map((b) => b.gate).join(", ")}`);
      break;
    }
  }

  return results;
}

async function runSingleGate(
  gateName: string,
  sessionId: string,
  config: AutonomousConfig
): Promise<GateResult> {
  const startTime = Date.now();
  const gateConfig = config.gates[gateName];

  let result: GateResult = {
    gate: gateName,
    score: 0,
    maxScore: gateConfig.weight,
    passed: false,
    issues: [],
    duration: 0,
    autoFixed: 0,
  };

  const agentName = getAgentNameForGate(gateName);

  try {
    for await (const message of query({
      prompt: `Use the ${agentName} agent to evaluate this codebase. Return only valid JSON.`,
      options: {
        resume: sessionId,
        allowedTools: ["Task", "Read", "Glob", "Grep", "Bash", "Edit"],
        agents: qualityGateAgents,
        permissionMode: gateConfig.auto_fix ? "acceptEdits" : "bypassPermissions",
      },
    })) {
      if ("result" in message) {
        try {
          const parsed = JSON.parse(extractJson(message.result));
          result.score = Math.min(parsed.score || 0, gateConfig.weight);
          result.passed = gateConfig.required
            ? result.score >= gateConfig.weight * 0.8
            : true;
          result.issues = parsed.issues || parsed.findings || [];
          result.autoFixed = parsed.fixed_count || parsed.fixed?.length || 0;
          metrics.autoFixesApplied += result.autoFixed;
        } catch (e) {
          console.error(`   [${gateName}] Failed to parse result`);
        }
      }
    }
  } catch (e) {
    console.error(`   [${gateName}] Gate execution failed:`, e);
  }

  result.duration = Date.now() - startTime;
  return result;
}

function getAgentNameForGate(gate: string): string {
  const mapping: Record<string, string> = {
    test: "test-runner",
    security: "security-auditor",
    build: "build-fixer",
    review: "code-reviewer",
    mentor: "mentor-advisor",
    ux: "ux-reviewer",
    architect: "architect-advisor",
    devops: "devops-advisor",
  };
  return mapping[gate] || `${gate}-runner`;
}

function extractJson(text: string): string {
  // Extract JSON from markdown code blocks or raw text
  const jsonMatch = text.match(/```json?\s*([\s\S]*?)```/);
  if (jsonMatch) {
    return jsonMatch[1].trim();
  }

  // Try to find raw JSON
  const braceMatch = text.match(/\{[\s\S]*\}/);
  if (braceMatch) {
    return braceMatch[0];
  }

  return text;
}

// ============================================
// ISSUE INTEGRATION
// ============================================
async function createSubIssue(
  parentIssue: string,
  gateIssue: GateIssue,
  gateName: string,
  sessionId: string
): Promise<string | null> {
  if (metrics.issuesCreated >= loadConfig().safety.max_issues_created_per_run) {
    console.log("   [LIMIT] Max issues created, skipping");
    return null;
  }

  const labels = [
    "auto-generated",
    gateName,
    gateIssue.severity,
    gateIssue.autoFixable ? "auto-fixable" : "manual-fix",
  ].join(",");

  const title = `[${gateName.toUpperCase()}] ${gateIssue.title}`;
  const body = `
## ${gateIssue.severity.toUpperCase()}: ${gateIssue.title}

**Found by:** \`/${gateName}\` gate
**File:** ${gateIssue.file || "N/A"}${gateIssue.line ? `:${gateIssue.line}` : ""}
**Auto-fixable:** ${gateIssue.autoFixable ? "Yes" : "No"}

### Description
${gateIssue.description}

### Recommendation
${gateIssue.recommendation || "Review and address manually."}

---
*Auto-generated by CodeAssist autonomous run*
*Parent issue: #${parentIssue}*
`.trim();

  try {
    for await (const message of query({
      prompt: `Create a GitHub issue with title "${title}" and labels "${labels}". Body:\n\n${body}`,
      options: {
        resume: sessionId,
        allowedTools: ["Bash"],
      },
    })) {
      if ("result" in message) {
        const issueMatch = message.result.match(/#(\d+)/);
        if (issueMatch) {
          metrics.issuesCreated++;
          return issueMatch[1];
        }
      }
    }
  } catch (e) {
    console.error("   Failed to create sub-issue:", e);
  }

  return null;
}

async function postToIssue(
  issueId: string,
  body: string,
  sessionId: string
): Promise<void> {
  try {
    for await (const _ of query({
      prompt: `Post this comment to GitHub issue #${issueId}:\n\n${body}`,
      options: {
        resume: sessionId,
        allowedTools: ["Bash"],
      },
    })) {
      // Comment posted
    }
  } catch (e) {
    console.error("   Failed to post to issue:", e);
  }
}

// ============================================
// PROGRESS REPORTING
// ============================================
function generateProgressReport(
  issueId: string,
  result: IterationResult
): string {
  const gateRows = result.gates
    .map((g) => {
      const status = g.passed ? "âœ…" : g.maxScore === 0 ? "â„¹ï¸" : "âŒ";
      return `| /${g.gate} | ${g.score}/${g.maxScore} | ${status} | ${g.issues.length} issues |`;
    })
    .join("\n");

  return `
## ğŸ”„ Autonomous Run - Iteration ${result.iteration}

**Status:** ${result.passed ? "âœ… Target Reached" : "ğŸ”„ In Progress"}
**Score:** ${result.totalScore}/${result.targetScore}
**Duration:** ${(result.duration / 1000).toFixed(1)}s

### Quality Gates

| Gate | Score | Status | Issues |
|------|-------|--------|--------|
${gateRows}

### Metrics
- API calls this iteration: ${result.apiCalls}
- Auto-fixes applied: ${metrics.autoFixesApplied}
- Files modified: ${metrics.filesModified.length}

---
*Iteration ${result.iteration} | Total duration: ${((Date.now() - metrics.startTime.getTime()) / 1000 / 60).toFixed(1)} min*
`.trim();
}

function generateFinalReport(
  issueId: string,
  result: IterationResult,
  createdIssues: string[]
): string {
  const gateRows = result.gates
    .map((g) => {
      const status = g.passed ? "âœ…" : g.maxScore === 0 ? "â„¹ï¸" : "âŒ";
      return `| /${g.gate} | ${g.score}/${g.maxScore} | ${status} |`;
    })
    .join("\n");

  const issuesList =
    createdIssues.length > 0
      ? createdIssues.map((id) => `- #${id}`).join("\n")
      : "None";

  return `
## âœ… Autonomous Run Complete

**Final Score:** ${result.totalScore}/${result.targetScore} ${result.passed ? "âœ…" : "âš ï¸"}
**Iterations:** ${result.iteration}
**Total Duration:** ${((Date.now() - metrics.startTime.getTime()) / 1000 / 60).toFixed(1)} minutes

### Quality Gates

| Gate | Score | Status |
|------|-------|--------|
${gateRows}

### Auto-Fixes Applied
${metrics.autoFixesApplied} issues fixed automatically

### Issues Created
${issuesList}

### Metrics
| Metric | Value |
|--------|-------|
| API calls | ${metrics.totalApiCalls} |
| Files modified | ${metrics.filesModified.length} |
| Iterations | ${metrics.iterations} |

---
*Generated by CodeAssist /autonomous*
`.trim();
}

// ============================================
// MAIN AUTONOMOUS LOOP
// ============================================
async function runAutonomousLoop(
  issueId: string,
  options: { preset?: string; supervised?: boolean }
): Promise<void> {
  const config = loadConfig(options.preset);
  let sessionId: string | undefined;
  let iteration = 0;
  let currentScore = 0;
  const createdIssues: string[] = [];

  console.log("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
  console.log("â•‘          RALPH WIGGUM - Autonomous Development            â•‘");
  console.log("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
  console.log(`â•‘  Issue: #${issueId.padEnd(50)}â•‘`);
  console.log(`â•‘  Target: ${config.target_score}/100${" ".repeat(44)}â•‘`);
  console.log(`â•‘  Max iterations: ${config.max_iterations}${" ".repeat(39)}â•‘`);
  console.log(`â•‘  Preset: ${(options.preset || "default").padEnd(48)}â•‘`);
  console.log("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

  // === PHASE 1: Setup and Implementation ===
  console.log("ğŸ“‹ Phase 1: Fetching issue and implementing...");

  for await (const message of query({
    prompt: `
You are starting an autonomous development session for issue #${issueId}.

STEPS:
1. Fetch issue #${issueId} from GitHub (use: gh issue view ${issueId})
2. Create feature branch: feature/${issueId}-implement
3. Read the issue description and acceptance criteria carefully
4. Implement the feature/fix based on requirements
5. Commit changes with format: "feat: description" or "fix: description"

RULES:
- NEVER push directly to main/master/staging
- NEVER include "Co-Authored-By: Claude" in commits
- Keep commits atomic and focused
- Follow existing code patterns

Begin implementation now.
`,
    options: {
      allowedTools: ["Read", "Edit", "Write", "Bash", "Glob", "Grep", "Task"],
      agents: qualityGateAgents,
      permissionMode: "acceptEdits",
      mcpServers: {
        github: { command: "npx", args: ["@anthropic-ai/mcp-github"] },
      },
      hooks: {
        PreToolUse: [
          { matcher: "Bash", hooks: [rateLimiter, blockForbiddenGit, stripClaudeAttribution] },
          { matcher: "Edit|Write", hooks: [rateLimiter] },
        ],
        PostToolUse: [{ matcher: "Edit|Write|Bash", hooks: [auditLog] }],
      },
    },
  })) {
    if (message.type === "system" && message.subtype === "init") {
      sessionId = message.session_id;
      console.log(`   Session: ${sessionId}`);
    }
    if ("result" in message) {
      console.log("   Implementation phase complete");
    }
  }

  if (!sessionId) {
    console.error("Failed to initialize session");
    return;
  }

  // === PHASE 2: Quality Gate Loop ===
  console.log("\nğŸ“Š Phase 2: Running quality gates...");

  const enabledGates = Object.keys(config.gates).filter(
    (gate) => config.gates[gate].weight > 0 || gate === "architect" || gate === "devops"
  );

  while (iteration < config.max_iterations && currentScore < config.target_score) {
    iteration++;
    metrics.iterations = iteration;
    const iterationStart = Date.now();
    const iterationApiStart = apiCallCount;

    console.log(`\n${"â”€".repeat(60)}`);
    console.log(`Iteration ${iteration}/${config.max_iterations}`);
    console.log(`${"â”€".repeat(60)}`);

    // Run gates in parallel groups
    const gateResults = await runGatesInParallel(enabledGates, sessionId, config);

    // Calculate score
    currentScore = gateResults
      .filter((g) => config.gates[g.gate].weight > 0)
      .reduce((sum, g) => sum + g.score, 0);

    // Add bonus points
    const testGate = gateResults.find((g) => g.gate === "test");
    if (testGate && testGate.score >= 25) {
      currentScore += 2;
      console.log("   [BONUS] +2 for excellent test coverage");
    }

    const reviewGate = gateResults.find((g) => g.gate === "review");
    if (reviewGate && reviewGate.issues.length === 0) {
      currentScore += 2;
      console.log("   [BONUS] +2 for zero code smells");
    }

    currentScore = Math.min(currentScore, 100);

    console.log(`\n   ğŸ“ˆ Score: ${currentScore}/${config.target_score}`);

    // Create result object
    const iterationResult: IterationResult = {
      iteration,
      totalScore: currentScore,
      targetScore: config.target_score,
      gates: gateResults,
      passed: currentScore >= config.target_score,
      duration: Date.now() - iterationStart,
      apiCalls: apiCallCount - iterationApiStart,
    };

    // Post progress to issue
    await postToIssue(
      issueId,
      generateProgressReport(issueId, iterationResult),
      sessionId
    );

    // Create issues for findings from advisory gates
    for (const gate of gateResults) {
      if (gate.gate === "architect" || gate.gate === "devops" || gate.gate === "mentor") {
        for (const issue of gate.issues.slice(0, 3)) {
          // Limit issues per gate
          if (issue.severity === "critical" || issue.severity === "high") {
            const newIssueId = await createSubIssue(issueId, issue, gate.gate, sessionId);
            if (newIssueId) {
              createdIssues.push(newIssueId);
              console.log(`   [ISSUE] Created #${newIssueId} for ${gate.gate} finding`);
            }
          }
        }
      }
    }

    // Check if we're done
    if (currentScore >= config.target_score) {
      console.log("\n   âœ… Target score reached!");
      break;
    }

    // Check for blockers
    const requiredFailed = gateResults.filter(
      (g) => config.gates[g.gate]?.required && !g.passed
    );

    if (requiredFailed.length > 0 && iteration >= 5) {
      console.log(`\n   ğŸš« BLOCKED: Required gates failed after ${iteration} iterations`);
      console.log(`      Failed: ${requiredFailed.map((g) => g.gate).join(", ")}`);

      await postToIssue(
        issueId,
        `## ğŸš« Autonomous Run Blocked\n\nRequired gates failed: ${requiredFailed.map((g) => `/${g.gate}`).join(", ")}\n\nComment \`@resume\` to retry after addressing issues.`,
        sessionId
      );
      return;
    }

    // Supervised mode: pause for user
    if (options.supervised) {
      console.log("\n   [SUPERVISED] Pausing for review...");
      console.log("   Press Ctrl+C to stop, or wait 30s to continue");
      await new Promise((resolve) => setTimeout(resolve, 30000));
    } else {
      // Iteration delay
      await new Promise((resolve) => setTimeout(resolve, config.iteration_delay * 1000));
    }
  }

  // === PHASE 3: Create PR ===
  if (currentScore >= config.target_score || (currentScore >= 85 && iteration >= config.max_iterations)) {
    console.log("\nğŸš€ Phase 3: Creating pull request...");

    const prLabel = currentScore >= config.target_score ? "" : "--label needs-review";

    for await (const message of query({
      prompt: `
Create a pull request from the current branch to staging.

REQUIREMENTS:
1. Title format: "feat: implement #${issueId} - [brief description]"
2. Include quality gate scores in the body
3. Link to issue #${issueId}
4. Add appropriate labels ${prLabel}

Use: gh pr create --fill --base staging

After creating, post the PR link to issue #${issueId}.
`,
      options: {
        resume: sessionId,
        allowedTools: ["Bash", "Read"],
      },
    })) {
      if ("result" in message) {
        console.log("   PR created successfully");
      }
    }

    // Post final summary
    const finalResult: IterationResult = {
      iteration,
      totalScore: currentScore,
      targetScore: config.target_score,
      gates: await runGatesInParallel(enabledGates, sessionId, config),
      passed: currentScore >= config.target_score,
      duration: Date.now() - metrics.startTime.getTime(),
      apiCalls: metrics.totalApiCalls,
    };

    await postToIssue(
      issueId,
      generateFinalReport(issueId, finalResult, createdIssues),
      sessionId
    );
  }

  // Save metrics
  writeFileSync(METRICS_FILE, JSON.stringify(metrics, null, 2));

  console.log("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
  console.log("â•‘                    RUN COMPLETE                           â•‘");
  console.log("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
  console.log(`â•‘  Final Score: ${currentScore}/${config.target_score}${" ".repeat(42)}â•‘`);
  console.log(`â•‘  Iterations: ${iteration}${" ".repeat(44)}â•‘`);
  console.log(`â•‘  Duration: ${((Date.now() - metrics.startTime.getTime()) / 1000 / 60).toFixed(1)} minutes${" ".repeat(39)}â•‘`);
  console.log(`â•‘  Issues Created: ${createdIssues.length}${" ".repeat(40)}â•‘`);
  console.log("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
}

// ============================================
// CLI ENTRY POINT
// ============================================
function parseArgs(): { issueId?: string; epicId?: string; preset?: string; supervised: boolean } {
  const args = process.argv.slice(2);
  return {
    issueId: args.find((a) => a.startsWith("--issue="))?.split("=")[1],
    epicId: args.find((a) => a.startsWith("--epic="))?.split("=")[1],
    preset: args.find((a) => a.startsWith("--preset="))?.split("=")[1],
    supervised: args.includes("--supervised"),
  };
}

function printUsage(): void {
  console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘        RALPH WIGGUM - Autonomous Development Runner           â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                               â•‘
â•‘  USAGE:                                                       â•‘
â•‘    npx ts-node ralph-runner.ts --issue=123                    â•‘
â•‘    npx ts-node ralph-runner.ts --epic=200                     â•‘
â•‘    npx ts-node ralph-runner.ts --issue=123 --preset=prod      â•‘
â•‘    npx ts-node ralph-runner.ts --issue=123 --supervised       â•‘
â•‘                                                               â•‘
â•‘  OPTIONS:                                                     â•‘
â•‘    --issue=ID      Run on a single issue                      â•‘
â•‘    --epic=ID       Run on all issues in epic                  â•‘
â•‘    --preset=NAME   Use config preset (default, production)    â•‘
â•‘    --supervised    Pause after each iteration                 â•‘
â•‘                                                               â•‘
â•‘  QUALITY GATES:                                               â•‘
â•‘    /test       25pts  Tests + coverage                        â•‘
â•‘    /security   25pts  Vulnerability scan                      â•‘
â•‘    /build      15pts  Compilation check                       â•‘
â•‘    /review     20pts  Code quality                            â•‘
â•‘    /mentor     10pts  Architecture advice                     â•‘
â•‘    /ux          5pts  UX/accessibility                        â•‘
â•‘    /architect   0pts  System security (creates issues)        â•‘
â•‘    /devops      0pts  CI/CD review (creates issues)           â•‘
â•‘                                                               â•‘
â•‘  CONFIG: .claude/autonomous.yml                               â•‘
â•‘                                                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
`);
}

// Main execution
const { issueId, epicId, preset, supervised } = parseArgs();

if (issueId) {
  runAutonomousLoop(issueId, { preset, supervised }).catch(console.error);
} else if (epicId) {
  console.log("Epic mode not yet implemented. Use --issue for now.");
} else {
  printUsage();
}
